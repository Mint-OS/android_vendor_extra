From 2b7192e30c8a93b716def9fc564e90867e0f96f3 Mon Sep 17 00:00:00 2001
From: bigrushdog <randall.rushing@gmail.com>
Date: Wed, 14 Dec 2016 01:06:32 -0800
Subject: [PATCH 1/3] Rewrite Masquerade for UID system ops [1/3]

Allow Substratum to offload a handful of functions
to system to support rootless operation

Credit @Surge1223 for cleaning up restartUI function
https://github.com/VelvetProject/packages_apps_masquerade/commit/3484db3dda1e7bf7e3f6fda049b903968f1506e7

Change-Id: Ie379fc81e5b80550e044df59c80a60b4890c340c
---
 app/src/main/AndroidManifest.xml                   |   33 +-
 .../substratum/activities/LoaderActivity.java      |   17 -
 .../substratum/receivers/BootReceiver.java         |   13 +
 .../UninstallReceiver.java}                        |   11 +-
 .../substratum/services/BootDetector.java          |   15 -
 .../masquerade/substratum/services/JobService.java | 1005 ++++++++++++++++++++
 .../masquerade/substratum/services/MasqDemo.java   |  137 +++
 .../java/masquerade/substratum/util/Helper.java    |  113 ---
 .../substratum/util/IconPackApplicator.java        |  136 ---
 .../substratum/util/ReadOverlaysFile.java          |   46 -
 .../main/java/masquerade/substratum/util/Root.java |   83 --
 .../masquerade/substratum/util/Uninstaller.java    |  107 ---
 .../java/masquerade/substratum/utils/IOUtils.java  |  170 ++++
 .../masquerade/substratum/utils/SoundUtils.java    |  210 ++++
 14 files changed, 1555 insertions(+), 541 deletions(-)
 delete mode 100644 app/src/main/java/masquerade/substratum/activities/LoaderActivity.java
 create mode 100644 app/src/main/java/masquerade/substratum/receivers/BootReceiver.java
 rename app/src/main/java/masquerade/substratum/{services/UninstallDetector.java => receivers/UninstallReceiver.java} (87%)
 delete mode 100644 app/src/main/java/masquerade/substratum/services/BootDetector.java
 create mode 100644 app/src/main/java/masquerade/substratum/services/JobService.java
 create mode 100644 app/src/main/java/masquerade/substratum/services/MasqDemo.java
 delete mode 100644 app/src/main/java/masquerade/substratum/util/Helper.java
 delete mode 100644 app/src/main/java/masquerade/substratum/util/IconPackApplicator.java
 delete mode 100644 app/src/main/java/masquerade/substratum/util/ReadOverlaysFile.java
 delete mode 100644 app/src/main/java/masquerade/substratum/util/Root.java
 delete mode 100644 app/src/main/java/masquerade/substratum/util/Uninstaller.java
 create mode 100644 app/src/main/java/masquerade/substratum/utils/IOUtils.java
 create mode 100644 app/src/main/java/masquerade/substratum/utils/SoundUtils.java

diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index aaffdf2..13db0f9 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -1,12 +1,20 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="masquerade.substratum"
-          android:versionCode="20"
-          android:versionName="twenty - procyon">
+          android:versionCode="21"
+          android:versionName="twentyone - something"
+          coreApp="true"
+          android:sharedUserId="android.uid.system">
 
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
     <uses-permission android:name="android.permission.CHANGE_CONFIGURATION"/>
+    <uses-permission android:name="android.permission.INTERACT_ACROSS_USERS_FULL" />
+    <uses-permission android:name="android.permission.FORCE_STOP_PACKAGES"/>
+    <uses-permission android:name="android.permission.DELETE_PACKAGES"/>
+    <uses-permission android:name="android.permission.INSTALL_PACKAGES"/>
+    <uses-permission android:name="android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS"/>
+    <uses-permission android:name="android.permission.MODIFY_OVERLAYS"/>
 
     <application
         android:allowBackup="true"
@@ -14,30 +22,19 @@
         android:label="@string/app_name"
         android:supportsRtl="true"
         android:theme="@style/AppTheme">
-        <receiver android:name="masquerade.substratum.services.BootDetector">
+        <receiver android:name=".receivers.BootReceiver">
             <intent-filter>
                 <action android:name="android.intent.action.BOOT_COMPLETED"/>
             </intent-filter>
         </receiver>
-        <receiver android:name=".services.UninstallDetector">
+        <receiver android:name=".receivers.UninstallReceiver">
             <intent-filter>
                 <action android:name="android.intent.action.PACKAGE_REMOVED"/>
                 <data android:scheme="package"/>
             </intent-filter>
         </receiver>
-        <receiver android:name=".util.Helper">
-            <intent-filter>
-                <action android:name="masquerade.substratum.COMMANDS"/>
-            </intent-filter>
-        </receiver>
-
-        <activity android:name="masquerade.substratum.activities.LoaderActivity">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN"/>
-                <action android:name="masquerade.substratum.INITIALIZE"/>
-
-                <category android:name="android.intent.category.DEFAULT"/>
-            </intent-filter>
-        </activity>
+        <service android:name=".services.JobService"
+            android:exported="true"
+            android:permission="android.permission.MODIFY_OVERLAYS" />
     </application>
 </manifest>
diff --git a/app/src/main/java/masquerade/substratum/activities/LoaderActivity.java b/app/src/main/java/masquerade/substratum/activities/LoaderActivity.java
deleted file mode 100644
index 3af5ec3..0000000
--- a/app/src/main/java/masquerade/substratum/activities/LoaderActivity.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package masquerade.substratum.activities;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.util.Log;
-
-import masquerade.substratum.util.Root;
-
-public class LoaderActivity extends Activity {
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        Log.d("Masquerade", "Masquerade is now securing superuser permissions!");
-        Root.requestRootAccess();
-        finish();
-    }
-}
\ No newline at end of file
diff --git a/app/src/main/java/masquerade/substratum/receivers/BootReceiver.java b/app/src/main/java/masquerade/substratum/receivers/BootReceiver.java
new file mode 100644
index 0000000..ebc0c8b
--- /dev/null
+++ b/app/src/main/java/masquerade/substratum/receivers/BootReceiver.java
@@ -0,0 +1,13 @@
+package masquerade.substratum.receivers;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+
+
+public class BootReceiver extends BroadcastReceiver {
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        // do something
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/masquerade/substratum/services/UninstallDetector.java b/app/src/main/java/masquerade/substratum/receivers/UninstallReceiver.java
similarity index 87%
rename from app/src/main/java/masquerade/substratum/services/UninstallDetector.java
rename to app/src/main/java/masquerade/substratum/receivers/UninstallReceiver.java
index 7af387b..b377e27 100644
--- a/app/src/main/java/masquerade/substratum/services/UninstallDetector.java
+++ b/app/src/main/java/masquerade/substratum/receivers/UninstallReceiver.java
@@ -1,4 +1,4 @@
-package masquerade.substratum.services;
+package masquerade.substratum.receivers;
 
 import android.content.BroadcastReceiver;
 import android.content.Context;
@@ -11,20 +11,18 @@ import android.util.Log;
 import java.util.ArrayList;
 import java.util.List;
 
-import masquerade.substratum.util.ReadOverlaysFile;
-import masquerade.substratum.util.Root;
 
-public class UninstallDetector extends BroadcastReceiver {
+public class UninstallReceiver extends BroadcastReceiver {
     @Override
     public void onReceive(Context context, Intent intent) {
         if ("android.intent.action.PACKAGE_REMOVED".equals(intent.getAction())) {
             Uri packageName = intent.getData();
             if (packageName.toString().substring(8).equals("projekt.substratum")) {
-                new performUninstalls().execute("");
+//                new performUninstalls().execute("");
             }
         }
     }
-
+/*
     public class performUninstalls extends AsyncTask<String, Integer, String> {
         @Override
         protected String doInBackground(String... sUrl) {
@@ -45,4 +43,5 @@ public class UninstallDetector extends BroadcastReceiver {
             return null;
         }
     }
+    */
 }
\ No newline at end of file
diff --git a/app/src/main/java/masquerade/substratum/services/BootDetector.java b/app/src/main/java/masquerade/substratum/services/BootDetector.java
deleted file mode 100644
index 3981487..0000000
--- a/app/src/main/java/masquerade/substratum/services/BootDetector.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package masquerade.substratum.services;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-
-import masquerade.substratum.util.Helper;
-
-public class BootDetector extends BroadcastReceiver {
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        Intent pushIntent = new Intent(context, Helper.class);
-        context.startService(pushIntent);
-    }
-}
\ No newline at end of file
diff --git a/app/src/main/java/masquerade/substratum/services/JobService.java b/app/src/main/java/masquerade/substratum/services/JobService.java
new file mode 100644
index 0000000..3c1b859
--- /dev/null
+++ b/app/src/main/java/masquerade/substratum/services/JobService.java
@@ -0,0 +1,1005 @@
+
+package masquerade.substratum.services;
+
+import android.app.ActivityManager;
+import android.app.ActivityManagerNative;
+import android.app.PendingIntent;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.IIntentReceiver;
+import android.content.IIntentSender;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.IntentSender;
+import android.content.om.IOverlayManager;
+import android.content.om.OverlayInfo;
+import android.content.pm.IPackageInstallObserver2;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageInstaller;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.res.AssetManager;
+import android.content.res.Configuration;
+import android.graphics.Typeface;
+import android.media.RingtoneManager;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.FileUtils;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Process;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+
+import masquerade.substratum.utils.IOUtils;
+import masquerade.substratum.utils.SoundUtils;
+
+import com.android.internal.statusbar.IStatusBarService;
+
+public class JobService extends Service {
+    private static final String TAG = JobService.class.getSimpleName();
+    private static final boolean DEBUG = true;
+
+    private static final String MASQUERADE_TOKEN = "masquerade_token";
+    private static final String SUBSTRATUM_PACKAGE = "projekt.substratum";
+    private static final String[] AUTHORIZED_CALLERS = new String[] {
+            SUBSTRATUM_PACKAGE,
+            "masquerade.substratum"
+    };
+
+    public static final String INTENT_STATUS_CHANGED = "masquerade.substratum.STATUS_CHANGED";
+
+    public static final String PRIMARY_COMMAND_KEY = "primary_command_key";
+    public static final String JOB_TIME_KEY = "job_time_key";
+    public static final String INSTALL_LIST_KEY = "install_list";
+    public static final String UNINSTALL_LIST_KEY = "uninstall_list";
+    public static final String WITH_RESTART_UI_KEY = "with_restart_ui";
+    public static final String BOOTANIMATION_FILE_NAME = "bootanimation_file_name";
+    public static final String FONTS_PID = "fonts_pid";
+    public static final String FONTS_FILENAME = "fonts_filename";
+    public static final String AUDIO_PID = "audio_pid";
+    public static final String AUDIO_FILENAME = "audio_filename";
+    public static final String COMMAND_VALUE_JOB_COMPLETE = "job_complete";
+    public static final String COMMAND_VALUE_INSTALL = "install";
+    public static final String COMMAND_VALUE_UNINSTALL = "uninstall";
+    public static final String COMMAND_VALUE_RESTART_UI = "restart_ui";
+    public static final String COMMAND_VALUE_CONFIGURATION_SHIM = "configuration_shim";
+    public static final String COMMAND_VALUE_BOOTANIMATION = "bootanimation";
+    public static final String COMMAND_VALUE_FONTS = "fonts";
+    public static final String COMMAND_VALUE_AUDIO = "audio";
+
+    private static IOverlayManager mOMS;
+    private static IPackageManager mPM;
+
+    private HandlerThread mWorker;
+    private JobHandler mJobHandler;
+    private MainHandler mMainHandler;
+    private final List<Runnable> mJobQueue = new ArrayList<>(0);
+    private long mLastJobTime;
+
+    @Override
+    public void onCreate() {
+        mWorker = new HandlerThread("BackgroundWorker", Process.THREAD_PRIORITY_BACKGROUND);
+        mWorker.start();
+        mJobHandler = new JobHandler(mWorker.getLooper());
+        mMainHandler = new MainHandler(Looper.getMainLooper());
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        // verify identity
+        if (!isCallerAuthorized(intent)) {
+            log("caller not authorized, aborting");
+            return START_NOT_STICKY;
+        }
+
+        // one job at a time please
+        // if (isProcessing()) {
+        // log("Got start command while still processing last job, aborting");
+        // return START_NOT_STICKY;
+        // }
+        // filter out duplicate intents
+        long jobTime = intent.getLongExtra(JOB_TIME_KEY, 1);
+        if (jobTime == 1 || jobTime == mLastJobTime) {
+            log("got empty jobtime or duplicate job time, aborting");
+            return START_NOT_STICKY;
+        }
+        mLastJobTime = jobTime;
+
+        // must have a primary command
+        String command = intent.getStringExtra(PRIMARY_COMMAND_KEY);
+        if (TextUtils.isEmpty(command)) {
+            log("Got empty primary command, aborting");
+            return START_NOT_STICKY;
+        }
+
+        // queue up the job
+
+        List<Runnable> jobs_to_add = new ArrayList<>(0);
+
+        log("Starting job with primary command " + command + " With job time " + jobTime);
+        if (TextUtils.equals(command, COMMAND_VALUE_INSTALL)) {
+            List<String> paths = intent.getStringArrayListExtra(INSTALL_LIST_KEY);
+            for (String path : paths) {
+                jobs_to_add.add(new Installer(path));
+            }
+        } else if (TextUtils.equals(command, COMMAND_VALUE_UNINSTALL)) {
+            List<String> packages = intent.getStringArrayListExtra(UNINSTALL_LIST_KEY);
+            for (String _package : packages) {
+                jobs_to_add.add(new Remover(_package));
+            }
+            if (intent.getBooleanExtra(WITH_RESTART_UI_KEY, false)) {
+                jobs_to_add.add(new UiResetJob());
+            }
+        } else if (TextUtils.equals(command, COMMAND_VALUE_RESTART_UI)) {
+            jobs_to_add.add(new UiResetJob());
+        } else if (TextUtils.equals(command, COMMAND_VALUE_CONFIGURATION_SHIM)) {
+            jobs_to_add.add(new LocaleChanger(getApplicationContext(), mMainHandler));
+        } else if (TextUtils.equals(command, COMMAND_VALUE_BOOTANIMATION)) {
+            String fileName = intent.getStringExtra(BOOTANIMATION_FILE_NAME);
+            if (TextUtils.isEmpty(fileName)) {
+                jobs_to_add.add(new BootAnimationJob(true));
+            } else {
+                jobs_to_add.add(new BootAnimationJob(fileName));
+            }
+        } else if (TextUtils.equals(command, COMMAND_VALUE_FONTS)) {
+            String pid = intent.getStringExtra(FONTS_PID);
+            String fileName = intent.getStringExtra(FONTS_FILENAME);
+            jobs_to_add.add(new FontsJob(pid, fileName));
+            jobs_to_add.add(new UiResetJob());
+        } else if (TextUtils.equals(command, COMMAND_VALUE_AUDIO)) {
+            String pid = intent.getStringExtra(AUDIO_PID);
+            String fileName = intent.getStringExtra(AUDIO_FILENAME);
+            jobs_to_add.add(new SoundsJob(pid, fileName));
+            jobs_to_add.add(new UiResetJob());
+        }
+
+        if (jobs_to_add.size() > 0) {
+            log("Adding new jobs to job queue");
+            synchronized (mJobQueue) {
+                mJobQueue.addAll(jobs_to_add);
+            }
+            if (!mJobHandler.hasMessages(JobHandler.MESSAGE_CHECK_QUEUE)) {
+                mJobHandler.sendEmptyMessage(JobHandler.MESSAGE_CHECK_QUEUE);
+            }
+        }
+
+        return START_NOT_STICKY;
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
+
+    @Override
+    public void onDestroy() {
+
+    }
+
+    private boolean isProcessing() {
+        return mJobQueue.size() > 0;
+    }
+
+    private class LocalService extends Binder {
+        public JobService getService() {
+            return JobService.this;
+        }
+    }
+
+    private static IOverlayManager getOMS() {
+        if (mOMS == null) {
+            mOMS = IOverlayManager.Stub.asInterface(
+                    ServiceManager.getService("overlay"));
+        }
+        return mOMS;
+    }
+
+    private static IPackageManager getPM() {
+        if (mPM == null) {
+            mPM = IPackageManager.Stub.asInterface(
+                    ServiceManager.getService("package"));
+        }
+        return mPM;
+    }
+
+    private void install(String path, IPackageInstallObserver2 observer) {
+        try {
+            getPM().installPackageAsUser(path, observer, PackageManager.INSTALL_REPLACE_EXISTING,
+                    null,
+                    UserHandle.USER_SYSTEM);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void uninstall(String packageName) {
+        try {
+            final LocalIntentReceiver receiver = new LocalIntentReceiver();
+            getPM().getPackageInstaller().uninstall(packageName, null /* callerPackageName */, 0,
+                    receiver.getIntentSender(), UserHandle.USER_SYSTEM);
+            final Intent result = receiver.getResult();
+            final int status = result.getIntExtra(PackageInstaller.EXTRA_STATUS,
+                    PackageInstaller.STATUS_FAILURE);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void disableOverlay(String packageName) {
+        try {
+            getOMS().setEnabled(packageName, false, UserHandle.USER_SYSTEM, false);
+        } catch (RemoteException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private boolean isOverlayEnabled(String packageName) {
+        boolean enabled = false;
+        try {
+            OverlayInfo info = getOMS().getOverlayInfo(packageName, UserHandle.USER_ALL);
+            enabled = info.isEnabled();
+        } catch (RemoteException e) {
+            e.printStackTrace();
+        }
+        return enabled;
+    }
+
+    private void copyFonts(String pid, String zipFileName) {
+        // prepare local cache dir for font package assembly
+        log("Copy Fonts - Package ID = " + pid + " filename = " + zipFileName);
+        File cacheDir = new File(getCacheDir(), "/FontCache/");
+        if (cacheDir.exists()) {
+            IOUtils.deleteRecursive(cacheDir);
+        }
+        cacheDir.mkdir();
+
+        // copy system fonts into our cache dir
+        IOUtils.copyFolder("/system/fonts", cacheDir.getAbsolutePath());
+
+        // append zip to filename since it is probably removed
+        // for list presentation
+        if (!zipFileName.endsWith(".zip")) {
+            zipFileName = zipFileName + ".zip";
+        }
+
+        // copy target themed fonts zip to our cache dir
+        Context themeContext = getAppContext(pid);
+        AssetManager am = themeContext.getAssets();
+        try {
+            InputStream inputStream = am.open("fonts/" + zipFileName);
+            OutputStream outputStream = new FileOutputStream(getCacheDir()
+                    .getAbsolutePath() + "/FontCache/" + zipFileName);
+            IOUtils.bufferedCopy(inputStream, outputStream);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        // unzip new fonts and delete zip file, overwriting any system fonts
+        File fontZip = new File(getCacheDir(), "/FontCache/" + zipFileName);
+        IOUtils.unzip(fontZip.getAbsolutePath(), cacheDir.getAbsolutePath());
+        fontZip.delete();
+
+        // check if theme zip included a fonts.xml. If not, Substratum
+        // is kind enough to provide one for us in it's assets
+        try {
+            File testConfig = new File(getCacheDir(), "/FontCache/" + "fonts.xml");
+            if (!testConfig.exists()) {
+                Context subContext = getSubsContext();
+                AssetManager subsAm = subContext.getAssets();
+                InputStream inputStream = subsAm.open("fonts.xml");
+                OutputStream outputStream = new FileOutputStream(testConfig);
+                IOUtils.bufferedCopy(inputStream, outputStream);
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        // prepare system theme fonts folder and copy new fonts folder from our cache
+        IOUtils.deleteThemedFonts();
+        IOUtils.createFontDirIfNotExists();
+        IOUtils.copyFolder(cacheDir.getAbsolutePath(), IOUtils.SYSTEM_THEME_FONT_PATH);
+
+        // set permissions on font files and config xml
+        File themeFonts = new File(IOUtils.SYSTEM_THEME_FONT_PATH);
+        for (File f : themeFonts.listFiles()) {
+            FileUtils.setPermissions(f,
+                    FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IRWXO, -1, -1);
+        }
+
+        // let system know it's time for a font change
+        SystemProperties.set("sys.refresh_theme", "1");
+        float fontSize = Float.valueOf(Settings.System.getString(
+                getContentResolver(), Settings.System.FONT_SCALE));
+        Settings.System.putString(getContentResolver(),
+                Settings.System.FONT_SCALE, String.valueOf(fontSize + 0.0000001));
+    }
+
+    private void clearFonts() {
+        IOUtils.deleteThemedFonts();
+        SystemProperties.set("sys.refresh_theme", "1");
+        Typeface.recreateDefaults();
+        float fontSize = Float.valueOf(Settings.System.getString(
+                getContentResolver(), Settings.System.FONT_SCALE));
+        Settings.System.putString(getContentResolver(),
+                Settings.System.FONT_SCALE, String.valueOf(fontSize + 0.0000001));
+    }
+
+    private void applyThemedSounds(String pid, String zipFileName) {
+        // prepare local cache dir for font package assembly
+        log("Copy sounds - Package ID = " + pid + " filename = " + zipFileName);
+        File cacheDir = new File(getCacheDir(), "/SoundsCache/");
+        if (cacheDir.exists()) {
+            IOUtils.deleteRecursive(cacheDir);
+        }
+        cacheDir.mkdir();
+
+        // append zip to filename since it is probably removed
+        // for list presentation
+        if (!zipFileName.endsWith(".zip")) {
+            zipFileName = zipFileName + ".zip";
+        }
+
+        // copy target themed sounds zip to our cache dir
+        Context themeContext = getAppContext(pid);
+        AssetManager am = themeContext.getAssets();
+        try {
+            InputStream inputStream = am.open("audio/" + zipFileName);
+            OutputStream outputStream = new FileOutputStream(getCacheDir()
+                    .getAbsolutePath() + "/SoundsCache/" + zipFileName);
+            IOUtils.bufferedCopy(inputStream, outputStream);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        // unzip new sounds and delete zip file
+        File soundsZip = new File(getCacheDir(), "/SoundsCache/" + zipFileName);
+        IOUtils.unzip(soundsZip.getAbsolutePath(), cacheDir.getAbsolutePath());
+        soundsZip.delete();
+
+        clearSounds(this);
+        IOUtils.createAudioDirIfNotExists();
+
+        File uiSoundsCache = new File(getCacheDir(), "/SoundsCache/ui/");
+        if (uiSoundsCache.exists() && uiSoundsCache.isDirectory()) {
+            IOUtils.createUiSoundsDirIfNotExists();
+            File effect_tick_mp3 = new File(getCacheDir(), "/SoundsCache/ui/Effect_Tick.mp3");
+            File effect_tick_ogg = new File(getCacheDir(), "/SoundsCache/ui/Effect_Tick.ogg");
+            if (effect_tick_ogg.exists()) {
+                IOUtils.bufferedCopy(effect_tick_ogg, new File(IOUtils.SYSTEM_THEME_UI_SOUNDS_PATH + File.separator + "Effect_Tick.ogg"));
+                SoundUtils.setUIAudible(this, effect_tick_ogg, new File
+                        ("/data/system/theme/audio/ui/Effect_Tick.ogg"), RingtoneManager
+                        .TYPE_RINGTONE, "Effect_Tick");
+            } else if (effect_tick_mp3.exists()) {
+                IOUtils.bufferedCopy(effect_tick_mp3, new File(IOUtils.SYSTEM_THEME_UI_SOUNDS_PATH + File.separator + "Effect_Tick.mp3"));
+                SoundUtils.setUIAudible(this, effect_tick_mp3, new File
+                        ("/data/system/theme/audio/ui/Effect_Tick.mp3"), RingtoneManager
+                        .TYPE_RINGTONE, "Effect_Tick");
+            } else {
+                SoundUtils.setDefaultUISounds(getContentResolver(), "lock_sound", "Lock.ogg");
+            }
+            File new_lock_mp3 = new File(getCacheDir(), "/SoundsCache/ui/Lock.mp3");
+            File new_lock_ogg = new File(getCacheDir(), "/SoundsCache/ui/Lock.ogg");
+            if (new_lock_ogg.exists()) {
+                IOUtils.bufferedCopy(new_lock_ogg, new File(IOUtils.SYSTEM_THEME_UI_SOUNDS_PATH + File.separator + "Lock.ogg"));
+                SoundUtils.setUISounds(getContentResolver(), "lock_sound", "/data/system/theme/audio/ui/Lock.ogg");
+            } else if (new_lock_mp3.exists()) {
+                IOUtils.bufferedCopy(new_lock_mp3, new File(IOUtils.SYSTEM_THEME_UI_SOUNDS_PATH + File.separator + "Lock.mp3"));
+                SoundUtils.setUISounds(getContentResolver(), "lock_sound", "/data/system/theme/audio/ui/Lock.mp3");
+            } else {
+                SoundUtils.setDefaultUISounds(getContentResolver(), "lock_sound", "Lock.ogg");
+            }
+            File new_unlock_mp3 = new File(getCacheDir(), "/SoundsCache/ui/Unlock.mp3");
+            File new_unlock_ogg = new File(getCacheDir(), "/SoundsCache/ui/Unlock.ogg");
+            if (new_unlock_ogg.exists()) {
+                IOUtils.bufferedCopy(new_unlock_ogg, new File(IOUtils.SYSTEM_THEME_UI_SOUNDS_PATH + File.separator + "Unlock.ogg"));
+                SoundUtils.setUISounds(getContentResolver(), "unlock_sound", "/data/system/theme/audio/ui/Unlock.ogg");
+            } else if (new_unlock_mp3.exists()) {
+                IOUtils.bufferedCopy(new_unlock_mp3, new File(IOUtils.SYSTEM_THEME_UI_SOUNDS_PATH + File.separator + "Unlock.mp3"));
+                SoundUtils.setUISounds(getContentResolver(), "unlock_sound", "/data/system/theme/audio/ui/Unlock.mp3");
+            } else {
+                SoundUtils.setDefaultUISounds(getContentResolver(), "unlock_sound", "Unlock.ogg");
+            }
+            File new_lowbattery_mp3 = new File(getCacheDir(), "/SoundsCache/ui/LowBattery.mp3");
+            File new_lowbattery_ogg = new File(getCacheDir(), "/SoundsCache/ui/LowBattery.ogg");
+            if (new_lowbattery_ogg.exists()) {
+                IOUtils.bufferedCopy(new_lowbattery_ogg, new File(IOUtils.SYSTEM_THEME_UI_SOUNDS_PATH + File.separator + "LowBattery.ogg"));
+                SoundUtils.setUISounds(getContentResolver(), "low_battery_sound", "/data/system/theme/audio/ui/LowBattery.ogg");
+            } else if (new_lowbattery_mp3.exists()) {
+                IOUtils.bufferedCopy(new_lowbattery_mp3, new File(IOUtils.SYSTEM_THEME_UI_SOUNDS_PATH + File.separator + "LowBattery.mp3"));
+                SoundUtils.setUISounds(getContentResolver(), "low_battery_sound", "/data/system/theme/audio/ui/LowBattery.mp3");
+            } else {
+                SoundUtils.setDefaultUISounds(getContentResolver(), "low_battery_sound", "LowBattery.ogg");
+            }
+            File uiSounds = new File(IOUtils.SYSTEM_THEME_UI_SOUNDS_PATH);
+            if (uiSounds.exists() && uiSounds.isDirectory()) {
+                for (File f : uiSounds.listFiles()) {
+                    FileUtils.setPermissions(f,
+                            FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IRWXO, -1, -1);
+                }
+            }
+        }
+        File alarmCache = new File(getCacheDir(), "/SoundsCache/alarms/");
+        if (alarmCache.exists() && alarmCache.isDirectory()) {
+            IOUtils.createAlarmDirIfNotExists();
+            File new_alarm_mp3 = new File(getCacheDir(), "/SoundsCache/alarms/alarm.mp3");
+            File new_alarm_ogg = new File(getCacheDir(), "/SoundsCache/alarms/alarm.ogg");
+            if (new_alarm_ogg.exists()) {
+                IOUtils.bufferedCopy(new_alarm_ogg, new File(IOUtils.SYSTEM_THEME_ALARM_PATH + File.separator + "alarm.ogg"));
+                int metaDataId = getSubsContext().getResources().getIdentifier("content_resolver_alarm_metadata", "string", SUBSTRATUM_PACKAGE);
+                SoundUtils.setAudible(this, new File("/data/system/theme/audio/alarms/alarm.ogg"),
+                        new File(alarmCache.getAbsolutePath(), "alarm.ogg"),
+                        RingtoneManager.TYPE_ALARM,
+                        getSubsContext().getString(metaDataId));
+            } else if (new_alarm_mp3.exists()) {
+                IOUtils.bufferedCopy(new_alarm_mp3, new File(IOUtils.SYSTEM_THEME_ALARM_PATH + File.separator + "alarm.mp3"));
+                int metaDataId = getSubsContext().getResources().getIdentifier("content_resolver_alarm_metadata", "string", SUBSTRATUM_PACKAGE);
+                SoundUtils.setAudible(this, new File("/data/system/theme/audio/alarms/alarm.mp3"),
+                        new File(alarmCache.getAbsolutePath(), "alarm.mp3"),
+                        RingtoneManager.TYPE_ALARM,
+                        getSubsContext().getString(metaDataId));
+            } else {
+                SoundUtils.setDefaultAudible(this, RingtoneManager.TYPE_ALARM);
+            }
+            File alarms = new File(IOUtils.SYSTEM_THEME_ALARM_PATH);
+            if (alarms.exists() && alarms.isDirectory()) {
+                for (File f : alarms.listFiles()) {
+                    FileUtils.setPermissions(f,
+                            FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IRWXO, -1, -1);
+                }
+            }
+        }
+        File notifCache = new File(getCacheDir(), "/SoundsCache/notifications/");
+        if (notifCache.exists() && notifCache.isDirectory()) {
+            IOUtils.createNotificationDirIfNotExists();
+            File new_notif_mp3 = new File(getCacheDir(), "/SoundsCache/notifications/notification.mp3");
+            File new_notif_ogg = new File(getCacheDir(), "/SoundsCache/notifications/notification.ogg");
+            if (new_notif_ogg.exists()) {
+                IOUtils.bufferedCopy(new_notif_ogg, new File(IOUtils.SYSTEM_THEME_NOTIFICATION_PATH + File.separator + "notification.ogg"));
+                int metaDataId = getSubsContext().getResources().getIdentifier("content_resolver_notification_metadata", "string", SUBSTRATUM_PACKAGE);
+                SoundUtils.setAudible(this, new File("/data/system/theme/audio/notifications/notification.ogg"),
+                        new File(notifCache.getAbsolutePath(), "notification.ogg"),
+                        RingtoneManager.TYPE_NOTIFICATION,
+                        getSubsContext().getString(metaDataId));
+            } else if (new_notif_mp3.exists()) {
+                IOUtils.bufferedCopy(new_notif_mp3, new File(IOUtils.SYSTEM_THEME_NOTIFICATION_PATH + File.separator + "notification.mp3"));
+                int metaDataId = getSubsContext().getResources().getIdentifier("content_resolver_notification_metadata", "string", SUBSTRATUM_PACKAGE);
+                SoundUtils.setAudible(this, new File("/data/system/theme/audio/notifications/notification.mp3"),
+                        new File(notifCache.getAbsolutePath(), "notification.mp3"),
+                        RingtoneManager.TYPE_NOTIFICATION,
+                        getSubsContext().getString(metaDataId));
+            } else {
+                SoundUtils.setDefaultAudible(this, RingtoneManager.TYPE_NOTIFICATION);
+            }
+            File notifs = new File(IOUtils.SYSTEM_THEME_NOTIFICATION_PATH);
+            if (notifs.exists() && notifs.isDirectory()) {
+                for (File f : notifs.listFiles()) {
+                    FileUtils.setPermissions(f,
+                            FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IRWXO, -1, -1);
+                }
+            }
+        }
+        File ringtoneCache = new File(getCacheDir(), "/SoundsCache/ringtones/");
+        if (ringtoneCache.exists() && ringtoneCache.isDirectory()) {
+            IOUtils.createRingtoneDirIfNotExists();
+            File new_ring_mp3 = new File(getCacheDir(), "/SoundsCache/ringtones/ringtone.mp3");
+            File new_ring_ogg = new File(getCacheDir(), "/SoundsCache/ringtones/ringtone.ogg");
+            if (new_ring_ogg.exists()) {
+                IOUtils.bufferedCopy(new_ring_ogg, new File(IOUtils.SYSTEM_THEME_RINGTONE_PATH + File.separator + "ringtone.ogg"));
+                int metaDataId = getSubsContext().getResources().getIdentifier("content_resolver_ringtone_metadata", "string", SUBSTRATUM_PACKAGE);
+                SoundUtils.setAudible(this, new File("/data/system/theme/audio/ringtones/ringtone.ogg"),
+                        new File(notifCache.getAbsolutePath(), "ringtone.ogg"),
+                        RingtoneManager.TYPE_RINGTONE,
+                        getSubsContext().getString(metaDataId));
+            } else if (new_ring_mp3.exists()) {
+                IOUtils.bufferedCopy(new_ring_mp3, new File(IOUtils.SYSTEM_THEME_RINGTONE_PATH + File.separator + "ringtone.mp3"));
+                int metaDataId = getSubsContext().getResources().getIdentifier("content_resolver_ringtone_metadata", "string", SUBSTRATUM_PACKAGE);
+                SoundUtils.setAudible(this, new File("/data/system/theme/audio/ringtones/ringtone.mp3"),
+                        new File(notifCache.getAbsolutePath(), "ringtone.mp3"),
+                        RingtoneManager.TYPE_RINGTONE,
+                        getSubsContext().getString(metaDataId));
+            } else {
+                SoundUtils.setDefaultAudible(this, RingtoneManager.TYPE_RINGTONE);
+            }
+            File rings = new File(IOUtils.SYSTEM_THEME_RINGTONE_PATH);
+            if (rings.exists() && rings.isDirectory()) {
+                for (File f : rings.listFiles()) {
+                    FileUtils.setPermissions(f,
+                            FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IRWXO, -1, -1);
+                }
+            }
+        }
+    }
+
+    private void clearSounds(Context ctx) {
+        IOUtils.deleteThemedAudio();
+        SoundUtils.setDefaultAudible(JobService.this, RingtoneManager.TYPE_ALARM);
+        SoundUtils.setDefaultAudible(JobService.this, RingtoneManager.TYPE_NOTIFICATION);
+        SoundUtils.setDefaultAudible(JobService.this, RingtoneManager.TYPE_RINGTONE);
+        SoundUtils.setDefaultUISounds(getContentResolver(), "lock_sound", "Lock.ogg");
+        SoundUtils.setDefaultUISounds(getContentResolver(), "unlock_sound", "Unlock.ogg");
+        SoundUtils.setDefaultUISounds(getContentResolver(), "low_battery_sound",
+                "LowBattery.ogg");
+    }
+
+    private void copyBootAnimation(String fileName) {
+        try {
+            clearBootAnimation();
+            File source = new File(fileName);
+            File dest = new File(IOUtils.SYSTEM_THEME_BOOTANIMATION_PATH);
+            IOUtils.bufferedCopy(source, dest);
+            source.delete();
+            FileUtils.setPermissions(IOUtils.SYSTEM_THEME_BOOTANIMATION_PATH,
+                    FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IROTH, -1, -1);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void clearBootAnimation() {
+        try {
+            File f = new File(IOUtils.SYSTEM_THEME_BOOTANIMATION_PATH);
+            if (f.exists()) {
+                f.delete();
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void restartUi() {
+        try {
+            ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
+            Class ActivityManagerNative = Class.forName("android.app.ActivityManagerNative");
+            Method getDefault = ActivityManagerNative.getDeclaredMethod("getDefault", null);
+            Object amn = getDefault.invoke(null, null);
+            Method killApplicationProcess = amn.getClass().getDeclaredMethod("killApplicationProcess", String.class, int.class);
+            stopService(new Intent().setComponent(new ComponentName("com.android.systemui", "com.android.systemui.SystemUIService")));
+            am.killBackgroundProcesses("com.android.systemui");
+            for (ActivityManager.RunningAppProcessInfo app : am.getRunningAppProcesses()) {
+                if ("com.android.systemui".equals(app.processName)) {
+                    killApplicationProcess.invoke(amn, app.processName, app.uid);
+                    break;
+                }
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void killPackage(String packageName) {
+        try {
+            ActivityManagerNative.getDefault().forceStopPackage(packageName,
+                    UserHandle.USER_SYSTEM);
+        } catch (RemoteException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private Context getSubsContext() {
+        return getAppContext(SUBSTRATUM_PACKAGE);
+    }
+
+    private Context getAppContext(String packageName) {
+        Context ctx = null;
+        try {
+            ctx = getApplicationContext().createPackageContext(packageName,
+                    Context.CONTEXT_IGNORE_SECURITY);
+        } catch (NameNotFoundException e) {
+            e.printStackTrace();
+        }
+        return ctx;
+    }
+
+    public static void log(String msg) {
+        if (DEBUG) {
+            Log.e(TAG, msg);
+        }
+    }
+
+    private boolean isCallerAuthorized(Intent intent) {
+        PendingIntent token = null;
+        try {
+            token = (PendingIntent) intent.getParcelableExtra(MASQUERADE_TOKEN);
+        } catch (Exception e) {
+            log("Attempt to start serivce without a token, unauthorized");
+        }
+        if (token == null) {
+            return false;
+        }
+        // SECOND: we got a token, validate originating package
+        // if not in our whitelist, return null
+        String callingPackage = token.getCreatorPackage();
+        boolean isValidPackage = false;
+        for (int i = 0; i < AUTHORIZED_CALLERS.length; i++) {
+            if (TextUtils.equals(callingPackage, AUTHORIZED_CALLERS[i])) {
+                log(callingPackage
+                        + " is an authorized calling package, next validate calling package perms");
+                isValidPackage = true;
+                break;
+            }
+        }
+        if (!isValidPackage) {
+            log(callingPackage + " is not an authorized calling package");
+            return false;
+        }
+        return true;
+    }
+
+    private class MainHandler extends Handler {
+        public static final int MSG_JOB_QUEUE_EMPTY = 1;
+
+        public MainHandler(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case MSG_JOB_QUEUE_EMPTY:
+                    Intent intent = new Intent(INTENT_STATUS_CHANGED);
+                    intent.putExtra(PRIMARY_COMMAND_KEY, COMMAND_VALUE_JOB_COMPLETE);
+                    sendBroadcastAsUser(intent, UserHandle.ALL);
+                    break;
+            }
+        }
+    }
+
+    private class JobHandler extends Handler {
+        private static final int MESSAGE_CHECK_QUEUE = 1;
+        private static final int MESSAGE_DEQUEUE = 2;
+
+        public JobHandler(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case MESSAGE_CHECK_QUEUE:
+                    Runnable job;
+                    synchronized (mJobQueue) {
+                        job = mJobQueue.get(0);
+                    }
+                    if (job != null) {
+                        job.run();
+                    }
+                    break;
+                case MESSAGE_DEQUEUE:
+                    Runnable toRemove = (Runnable) msg.obj;
+                    synchronized (mJobQueue) {
+                        mJobQueue.remove(toRemove);
+                        if (mJobQueue.size() > 0) {
+                            this.sendEmptyMessage(MESSAGE_CHECK_QUEUE);
+                        } else {
+                            log("Job queue empty! All done");
+                            mMainHandler.sendEmptyMessage(MainHandler.MSG_JOB_QUEUE_EMPTY);
+                        }
+                    }
+                    break;
+                default:
+                    log("Unknown message " + msg.what);
+                    break;
+            }
+        }
+    }
+
+    private class StopPackageJob implements Runnable {
+        String mPackage;
+
+        public void StopPackageJob(String _package) {
+            mPackage = _package;
+        }
+
+        @Override
+        public void run() {
+            killPackage(mPackage);
+            log("Killed package " + mPackage);
+            Message message = mJobHandler.obtainMessage(JobHandler.MESSAGE_DEQUEUE,
+                    StopPackageJob.this);
+            mJobHandler.sendMessage(message);
+        }
+    }
+
+    private class UiResetJob implements Runnable {
+        @Override
+        public void run() {
+            restartUi();
+            log("Restarting SystemUI...");
+            Message message = mJobHandler.obtainMessage(JobHandler.MESSAGE_DEQUEUE,
+                    UiResetJob.this);
+            mJobHandler.sendMessage(message);
+        }
+    }
+
+    private class FontsJob implements Runnable {
+        boolean mClear;
+        String mPid;
+        String mFileName;
+
+        public FontsJob(String pid, String fileName) {
+            if (pid == null) {
+                mClear = true;
+            } else {
+                mPid = pid;
+                mFileName = fileName;
+            }
+        }
+
+        @Override
+        public void run() {
+            if (mClear) {
+                log("Resetting system font");
+                clearFonts();
+            } else {
+                log("Setting theme font");
+                copyFonts(mPid, mFileName);
+            }
+            Intent intent = new Intent(INTENT_STATUS_CHANGED);
+            intent.putExtra(PRIMARY_COMMAND_KEY, COMMAND_VALUE_FONTS);
+            sendBroadcastAsUser(intent, UserHandle.ALL);
+            Message message = mJobHandler.obtainMessage(JobHandler.MESSAGE_DEQUEUE,
+                    FontsJob.this);
+            mJobHandler.sendMessage(message);
+        }
+    }
+
+    private class SoundsJob implements Runnable {
+        boolean mClear;
+        String mPid;
+        String mFileName;
+
+        public SoundsJob(String pid, String fileName) {
+            if (pid == null) {
+                mClear = true;
+            } else {
+                mPid = pid;
+                mFileName = fileName;
+            }
+        }
+
+        @Override
+        public void run() {
+            if (mClear) {
+                log("Resetting system sounds");
+                clearSounds(JobService.this);
+            } else {
+                log("Setting theme sounds");
+                applyThemedSounds(mPid, mFileName);
+            }
+            Intent intent = new Intent(INTENT_STATUS_CHANGED);
+            intent.putExtra(PRIMARY_COMMAND_KEY, COMMAND_VALUE_AUDIO);
+            sendBroadcastAsUser(intent, UserHandle.ALL);
+            Message message = mJobHandler.obtainMessage(JobHandler.MESSAGE_DEQUEUE,
+                    SoundsJob.this);
+            mJobHandler.sendMessage(message);
+        }
+    }
+
+    private class BootAnimationJob implements Runnable {
+        String mFileName;
+        final boolean mClear;
+
+        public BootAnimationJob(boolean clear) {
+            mClear = true;
+        }
+
+        public BootAnimationJob(String fileName) {
+            mFileName = fileName;
+            mClear = false;
+        }
+
+        @Override
+        public void run() {
+            if (mClear) {
+                log("Resetting system boot animation");
+                clearBootAnimation();
+            } else {
+                log("Setting themed boot animation");
+                copyBootAnimation(mFileName);
+            }
+            Intent intent = new Intent(INTENT_STATUS_CHANGED);
+            intent.putExtra(PRIMARY_COMMAND_KEY, COMMAND_VALUE_BOOTANIMATION);
+            sendBroadcastAsUser(intent, UserHandle.ALL);
+            Message message = mJobHandler.obtainMessage(JobHandler.MESSAGE_DEQUEUE,
+                    BootAnimationJob.this);
+            mJobHandler.sendMessage(message);
+        }
+    }
+
+    private class Installer implements Runnable, IPackageInstallObserver2 {
+        String mPath;
+
+        public Installer(String path) {
+            mPath = path;
+        }
+
+        @Override
+        public IBinder asBinder() {
+            return null;
+        }
+
+        @Override
+        public void onUserActionRequired(Intent intent) throws RemoteException {
+            log("Installer - user action required callback with " + mPath);
+        }
+
+        @Override
+        public void onPackageInstalled(String basePackageName, int returnCode, String msg,
+                Bundle extras) throws RemoteException {
+            log("Installer - successfully installed " + basePackageName + " from " + mPath);
+            Message message = mJobHandler.obtainMessage(JobHandler.MESSAGE_DEQUEUE, Installer.this);
+            mJobHandler.sendMessage(message);
+        }
+
+        @Override
+        public void run() {
+            log("Installer - installing " + mPath);
+            install(mPath, this);
+        }
+    }
+
+    private class Remover implements Runnable {
+        String mPackage;
+
+        public Remover(String _package) {
+            mPackage = _package;
+        }
+
+        @Override
+        public void run() {
+            if (isOverlayEnabled(mPackage)) {
+                log("Remover - disabling overlay for " + mPackage);
+                disableOverlay(mPackage);
+            }
+            log("Remover - uninstalling " + mPackage);
+            uninstall(mPackage);
+        }
+    }
+
+    private class LocaleChanger extends BroadcastReceiver implements Runnable {
+        private boolean mIsRegistered;
+        private boolean mDoRestore;
+        private Context mContext;
+        private Handler mHandler;
+        private Locale mCurrentLocale;
+
+        public LocaleChanger(Context context, Handler mainHandler) {
+            mContext = context;
+            mHandler = mainHandler;
+        }
+
+        @Override
+        public void run() {
+            Intent i = new Intent(Intent.ACTION_MAIN);
+            i.addCategory(Intent.CATEGORY_HOME);
+            mContext.startActivity(i);
+            mHandler.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    spoofLocale();
+                }
+            }, 500);
+        }
+
+        private void register() {
+            if (!mIsRegistered) {
+                IntentFilter filter = new IntentFilter();
+                filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
+                mContext.registerReceiver(LocaleChanger.this, filter);
+                mIsRegistered = true;
+            }
+        }
+
+        private void unregister() {
+            if (mIsRegistered) {
+                mContext.unregisterReceiver(LocaleChanger.this);
+                mIsRegistered = false;
+            }
+        }
+
+        private void spoofLocale() {
+            Configuration config;
+            log("LocaleChanger - spoofing locale for configuation change shim");
+            try {
+                register();
+                config = ActivityManagerNative.getDefault().getConfiguration();
+                mCurrentLocale = config.locale;
+                Locale toSpoof = Locale.JAPAN;
+                if (mCurrentLocale == Locale.JAPAN) {
+                    toSpoof = Locale.CHINA;
+                }
+                config.setLocale(toSpoof);
+                config.userSetLocale = true;
+                ActivityManagerNative.getDefault().updateConfiguration(config);
+            } catch (RemoteException e) {
+                e.printStackTrace();
+                return;
+            }
+        }
+
+        private void restoreLocale() {
+            Configuration config;
+            log("LocaleChanger - restoring original locale for configuation change shim");
+            try {
+                unregister();
+                config = ActivityManagerNative.getDefault().getConfiguration();
+                config.setLocale(mCurrentLocale);
+                config.userSetLocale = true;
+                ActivityManagerNative.getDefault().updateConfiguration(config);
+            } catch (RemoteException e) {
+                e.printStackTrace();
+                return;
+            }
+            Message message = mJobHandler.obtainMessage(JobHandler.MESSAGE_DEQUEUE,
+                    LocaleChanger.this);
+            mJobHandler.sendMessage(message);
+        }
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            mHandler.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    restoreLocale();
+                }
+            }, 500);
+        }
+    }
+
+    private static class LocalIntentReceiver {
+        private final SynchronousQueue<Intent> mResult = new SynchronousQueue<>();
+
+        private IIntentSender.Stub mLocalSender = new IIntentSender.Stub() {
+            @Override
+            public void send(int code, Intent intent, String resolvedType,
+                    IIntentReceiver finishedReceiver, String requiredPermission, Bundle options) {
+                try {
+                    mResult.offer(intent, 5, TimeUnit.SECONDS);
+                } catch (InterruptedException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        };
+
+        public IntentSender getIntentSender() {
+            return new IntentSender((IIntentSender) mLocalSender);
+        }
+
+        public Intent getResult() {
+            try {
+                return mResult.take();
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+}
diff --git a/app/src/main/java/masquerade/substratum/services/MasqDemo.java b/app/src/main/java/masquerade/substratum/services/MasqDemo.java
new file mode 100644
index 0000000..b00d6e0
--- /dev/null
+++ b/app/src/main/java/masquerade/substratum/services/MasqDemo.java
@@ -0,0 +1,137 @@
+
+package masquerade.substratum.services;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.text.TextUtils;
+
+public class MasqDemo {
+    public static final String MASQUERADE_TOKEN = "masquerade_token";
+    public static final String PRIMARY_COMMAND_KEY = "primary_command_key";
+    public static final String JOB_TIME_KEY = "job_time_key";
+    public static final String INSTALL_LIST_KEY = "install_list";
+    public static final String UNINSTALL_LIST_KEY = "uninstall_list";
+    public static final String WITH_RESTART_UI_KEY = "with_restart_ui";
+    public static final String BOOTANIMATION_PID_KEY = "bootanimation_pid";
+    public static final String BOOTANIMATION_FILE_NAME = "bootanimation_file_name";
+    public static final String FONTS_PID = "fonts_pid";
+    public static final String FONTS_FILENAME = "fonts_filename";
+    public static final String AUDIO_PID = "audio_pid";
+    public static final String AUDIO_FILENAME = "audio_filename";
+    public static final String COMMAND_VALUE_INSTALL = "install";
+    public static final String COMMAND_VALUE_UNINSTALL = "uninstall";
+    public static final String COMMAND_VALUE_RESTART_UI = "restart_ui";
+    public static final String COMMAND_VALUE_CONFIGURATION_SHIM = "configuration_shim";
+    public static final String COMMAND_VALUE_BOOTANIMATION = "bootanimation";
+    public static final String COMMAND_VALUE_FONTS = "fonts";
+    public static final String COMMAND_VALUE_AUDIO = "audio";
+    public static final String INTENT_STATUS_CHANGED = "masquerade.substratum.STATUS_CHANGED";
+    public static final String COMMAND_VALUE_JOB_COMPLETE = "job_complete";
+
+    class MasqReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (TextUtils.equals(intent.getAction(), INTENT_STATUS_CHANGED)) {
+                String command = intent.getStringExtra(PRIMARY_COMMAND_KEY);
+                if (TextUtils.equals(command, COMMAND_VALUE_FONTS)) {
+                    // update ui, dismiss progress dialog, etc
+                } else if (TextUtils.equals(command, COMMAND_VALUE_BOOTANIMATION)) {
+
+                } else if (TextUtils.equals(command, COMMAND_VALUE_AUDIO)) {
+
+                } else if (TextUtils.equals(command, COMMAND_VALUE_JOB_COMPLETE)) {
+
+                }
+            }
+        }
+    }
+
+    // demo code for building a base intent for JobService commands
+    public static Intent getMasqIntent(Context ctx) {
+        Intent intent = new Intent();
+        intent.setClassName("masquerade.substratum", "masquerade.substratum.services.JobService");
+        // Credit StackOverflow http://stackoverflow.com/a/28132098
+        // Use dummy PendingIntent for service to validate caller at onBind
+        PendingIntent pending = PendingIntent.getActivity(ctx, 0, new Intent(), 0);
+        intent.putExtra(MASQUERADE_TOKEN, pending);
+        intent.putExtra(JOB_TIME_KEY, System.currentTimeMillis());
+        return intent;
+    }
+
+    public static void install(Context context, ArrayList<String> overlay_apks) {
+        // populate list however
+        Intent masqIntent = getMasqIntent(context);
+        masqIntent.putExtra(PRIMARY_COMMAND_KEY, COMMAND_VALUE_INSTALL);
+        masqIntent.putExtra(INSTALL_LIST_KEY, overlay_apks);
+        context.startService(masqIntent);
+    }
+
+    public static void uninstall(Context context, ArrayList<String> packages_to_remove) {
+        Intent masqIntent = getMasqIntent(context);
+        masqIntent.putExtra(PRIMARY_COMMAND_KEY, COMMAND_VALUE_UNINSTALL);
+        masqIntent.putExtra(UNINSTALL_LIST_KEY, packages_to_remove);
+        // only need to set if true, will restart SystemUI when done processing packages
+        masqIntent.putExtra(WITH_RESTART_UI_KEY, true);
+        context.startService(masqIntent);
+    }
+
+    public static void restartSystemUI(Context context) {
+        Intent masqIntent = getMasqIntent(context);
+        masqIntent.putExtra(PRIMARY_COMMAND_KEY, COMMAND_VALUE_RESTART_UI);
+        context.startService(masqIntent);
+    }
+
+    public static void configurationChangeShim(Context context) {
+        Intent masqIntent = getMasqIntent(context);
+        masqIntent.putExtra(PRIMARY_COMMAND_KEY, COMMAND_VALUE_CONFIGURATION_SHIM);
+        context.startService(masqIntent);
+    }
+    
+    public static void clearThemedBootAnimation(Context context) {
+        applyThemedBootAnimation(context, null);
+    }
+    
+    public static void applyThemedBootAnimation(Context context, String fileName) {
+        Intent masqIntent = getMasqIntent(context);
+        masqIntent.putExtra(PRIMARY_COMMAND_KEY, COMMAND_VALUE_BOOTANIMATION);
+        if (fileName != null) {
+            masqIntent.putExtra(BOOTANIMATION_FILE_NAME, fileName);
+        } else {
+            // nothing. to reset to stock, just don't add PID and FILE
+        }
+        context.startService(masqIntent);
+    }
+    
+    public static void clearThemedFont(Context context) {
+        applyThemedFont(context, null, null);
+    }
+
+    public static void applyThemedFont(Context context, String pid, String fileName) {
+        Intent masqIntent = getMasqIntent(context);
+        masqIntent.putExtra(PRIMARY_COMMAND_KEY, COMMAND_VALUE_FONTS);
+        if (pid != null) {
+            masqIntent.putExtra(FONTS_PID, pid);
+            masqIntent.putExtra(FONTS_FILENAME, fileName);
+        }
+        context.startService(masqIntent);
+    }
+
+    public static void clearThemedSounds(Context context) {
+        applyThemedSounds(context, null, null);
+    }
+
+    public static void applyThemedSounds(Context context, String pid, String fileName) {
+        Intent masqIntent = getMasqIntent(context);
+        masqIntent.putExtra(PRIMARY_COMMAND_KEY, COMMAND_VALUE_AUDIO);
+        if (pid != null) {
+            masqIntent.putExtra(AUDIO_PID, pid);
+            masqIntent.putExtra(AUDIO_FILENAME, fileName);
+        }
+        context.startService(masqIntent);
+    }
+}
diff --git a/app/src/main/java/masquerade/substratum/util/Helper.java b/app/src/main/java/masquerade/substratum/util/Helper.java
deleted file mode 100644
index cccf493..0000000
--- a/app/src/main/java/masquerade/substratum/util/Helper.java
+++ /dev/null
@@ -1,113 +0,0 @@
-package masquerade.substratum.util;
-
-import android.app.PendingIntent;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Handler;
-import android.text.TextUtils;
-import android.util.Log;
-
-public class Helper extends BroadcastReceiver {
-
-    private static final String SUBSTRATUM_PACKAGE = "projekt.substratum";
-    private static final String MASQUERADE_TOKEN = "masquerade_token";
-    private static final String[] AUTHORIZED_CALLERS = new String[]{
-            SUBSTRATUM_PACKAGE,
-            "masquerade.substratum"
-    };
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        if (!isCallerAuthorized(intent)) {
-            Log.d("Masquerade", "Caller not authorized");
-            return;
-        }
-        Log.d("Masquerade",
-                "BroadcastReceiver has accepted Substratum's commands and is running now...");
-        Root.requestRootAccess();
-
-        if (intent.getStringExtra("substratum-check") != null) {
-            if (intent.getStringExtra("substratum-check").equals("masquerade-ball")) {
-                Intent runCommand = new Intent();
-                runCommand.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);
-                runCommand.setAction("projekt.substratum.MASQUERADE_BALL");
-                runCommand.putExtra("substratum-check", "masquerade-ball");
-                context.sendBroadcast(runCommand);
-                Log.d("Masquerade", "BroadcastReceiver was triggered to check for system " +
-                        "integrity and service activation.");
-            }
-        } else if (intent.getStringArrayListExtra("pm-uninstall") != null) {
-            new Uninstaller().uninstall(intent, "pm-uninstall", false,
-                    intent.getBooleanExtra("restart_systemui", false));
-        } else if (intent.getStringArrayListExtra("pm-uninstall-specific") != null) {
-            new Uninstaller().uninstall(intent, "pm-uninstall-specific", true,
-                    intent.getBooleanExtra("restart_systemui", false));
-        } else if (intent.getStringArrayListExtra("icon-handler") != null) {
-            String icon_pack_name = intent.getStringArrayListExtra("icon-handler").get(0);
-            String main_delay = intent.getStringArrayListExtra("icon-handler").get(2);
-            String delay_one = intent.getStringArrayListExtra("icon-handler").get(3);
-            String delay_two = intent.getStringArrayListExtra("icon-handler").get(4);
-            final String bypass = intent.getStringArrayListExtra("icon-handler").get(5);
-            if (bypass == null) {
-                if (intent.getStringArrayListExtra("icon-handler").get(1).contains("pm") ||
-                        intent.getStringArrayListExtra("icon-handler").get(1).contains("om") ||
-                        intent.getStringArrayListExtra("icon-handler").get(1).contains("overlay")) {
-                    Log.d("Masquerade", "Running command: \"" +
-                            intent.getStringArrayListExtra("icon-handler").get(1) + "\"");
-                    Root.runCommand(intent.getStringArrayListExtra("icon-handler").get(1));
-                }
-            }
-            final Context mContext = context;
-            final String icon_pack = icon_pack_name;
-            final String delay_one_time = delay_one;
-            final String delay_two_time = delay_two;
-            final Handler handle = new Handler();
-            handle.postDelayed(new Runnable() {
-                @Override
-                public void run() {
-                    new IconPackApplicator().apply(
-                            mContext, icon_pack, delay_one_time, delay_two_time, bypass == null);
-                }
-            }, Integer.parseInt(main_delay));
-        } else if (intent.getStringExtra("om-commands") != null) {
-            if (intent.getStringExtra("om-commands").contains("pm") ||
-                    intent.getStringExtra("om-commands").contains("om") ||
-                    intent.getStringExtra("om-commands").contains("overlay")) {
-                Log.d("Masquerade", "Running command: \"" +
-                        intent.getStringExtra("om-commands") + "\"");
-                Root.runCommand(intent.getStringExtra("om-commands"));
-            }
-        }
-    }
-
-    private boolean isCallerAuthorized(Intent intent) {
-        PendingIntent token = null;
-        try {
-            token = intent.getParcelableExtra(MASQUERADE_TOKEN);
-        } catch (Exception e) {
-            Log.d("Masquerade", "Attempt to start service without a token, unauthorized");
-        }
-        if (token == null) {
-            return false;
-        }
-        // SECOND: we got a token, validate originating package
-        // if not in our white list, return null
-        String callingPackage = token.getCreatorPackage();
-        boolean isValidPackage = false;
-        for (int i = 0; i < AUTHORIZED_CALLERS.length; i++) {
-            if (TextUtils.equals(callingPackage, AUTHORIZED_CALLERS[i])) {
-                Log.d("Masquerade", callingPackage
-                        + " is an authorized calling package, next validate calling package perms");
-                isValidPackage = true;
-                break;
-            }
-        }
-        if (!isValidPackage) {
-            Log.d("Masquerade", callingPackage
-                    + " is not an authorized calling package");
-            return false;
-        }
-        return true;
-    }
-}
\ No newline at end of file
diff --git a/app/src/main/java/masquerade/substratum/util/IconPackApplicator.java b/app/src/main/java/masquerade/substratum/util/IconPackApplicator.java
deleted file mode 100644
index fb5d682..0000000
--- a/app/src/main/java/masquerade/substratum/util/IconPackApplicator.java
+++ /dev/null
@@ -1,136 +0,0 @@
-package masquerade.substratum.util;
-
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.res.Resources;
-import android.os.Handler;
-import android.util.Log;
-import android.widget.Toast;
-
-import java.util.Locale;
-
-class IconPackApplicator {
-
-    private Context mContext;
-    private String iconPackName;
-    private String toast_text = null;
-    private int delayOne, delayTwo;
-    private Boolean bypass;
-
-    private static void grantPermission(final String packager, final String permission) {
-        Root.runCommand("pm grant " + packager + " " + permission);
-    }
-
-    void apply(Context mContext, String iconPackName, String delayOne, String delayTwo,
-               Boolean bypass) {
-        this.mContext = mContext;
-        this.iconPackName = iconPackName;
-        this.delayOne = Integer.parseInt(delayOne);
-        this.delayTwo = Integer.parseInt(delayTwo);
-        this.bypass = bypass;
-        iconInjector();
-    }
-
-    private boolean checkChangeConfigurationPermissions() {
-        String permission = "android.permission.CHANGE_CONFIGURATION";
-        int res = mContext.checkCallingOrSelfPermission(permission);
-        return (res == PackageManager.PERMISSION_GRANTED);
-    }
-
-    private void iconInjector() {
-        if (!checkChangeConfigurationPermissions()) {
-            Log.e("Masquerade", "Masquerade was not granted " +
-                    "CHANGE_CONFIGURATION permissions, allowing now...");
-            grantPermission("masquerade.substratum",
-                    "android.permission.CHANGE_CONFIGURATION");
-        } else {
-            Log.d("Masquerade",
-                    "Masquerade already granted CHANGE_CONFIGURATION permissions!");
-        }
-        try {
-            // Move home, since this is where we want our config code affected
-            Intent i = new Intent(Intent.ACTION_MAIN);
-            i.addCategory(Intent.CATEGORY_HOME);
-            mContext.startActivity(i);
-
-            // Take a fragment of memory to remember what the user's default config is
-            final Locale current_locale = mContext.getResources().getConfiguration().locale;
-            Locale to_be_changed = Locale.JAPAN;
-            // There are definitely Japanese locale users using our app, so we should take
-            // account for these people and switch to Chinese for 2 seconds.
-            if (current_locale == Locale.JAPAN) {
-                to_be_changed = Locale.CHINA;
-            }
-            final Locale changer = to_be_changed;
-
-            // Reflect back to framework and cause the language to change, we need this!
-            Class<?> activityManagerNative = Class.forName("android.app.ActivityManagerNative");
-            final Object am = activityManagerNative.getMethod("getDefault").invoke
-                    (activityManagerNative);
-            final Object config = am.getClass().getMethod("getConfiguration").invoke(am);
-
-            // Sniff Substratum's Resources
-            try {
-                Context otherContext = mContext.createPackageContext("projekt.substratum", 0);
-                Resources resources = otherContext.getResources();
-                if (bypass) {
-                    int toast = resources.getIdentifier("studio_applied_toast", "string",
-                            "projekt.substratum");
-                    toast_text = String.format(resources.getString(toast), iconPackName);
-                } else {
-                    int toast = resources.getIdentifier("studio_configuration_changed", "string",
-                            "projekt.substratum");
-                    toast_text = resources.getString(toast);
-                }
-            } catch (Exception e) {
-                // Suppress warning
-            }
-
-            // First window refresh to kick the change on the home screen
-            final Handler handle = new Handler();
-            handle.postDelayed(new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        config.getClass().getDeclaredField(
-                                "locale").set(config, changer);
-                        config.getClass().getDeclaredField(
-                                "userSetLocale").setBoolean(config, true);
-
-                        am.getClass().getMethod("updateConfiguration",
-                                android.content.res.Configuration.class).invoke(am, config);
-
-                        // Change the locale back to pre-icon pack application
-                        final Handler handler = new Handler();
-                        handler.postDelayed(new Runnable() {
-                            @Override
-                            public void run() {
-                                try {
-                                    config.getClass().getDeclaredField("locale").set(
-                                            config, current_locale);
-                                    config.getClass().getDeclaredField("userSetLocale")
-                                            .setBoolean(config, true);
-
-                                    am.getClass().getMethod("updateConfiguration",
-                                            android.content.res.Configuration
-                                                    .class).invoke(am, config);
-
-                                    if (toast_text != null)
-                                        Toast.makeText(
-                                                mContext, toast_text, Toast.LENGTH_SHORT).show();
-                                } catch (Exception e) {
-                                    // Suppress warning
-                                }
-                            }
-                        }, delayTwo); // 2 second delay for Home refresh
-                    } catch (Exception e) {
-                        // Suppress warning
-                    }
-                }
-            }, delayOne); // 1 second delay for Home refresh
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-}
\ No newline at end of file
diff --git a/app/src/main/java/masquerade/substratum/util/ReadOverlaysFile.java b/app/src/main/java/masquerade/substratum/util/ReadOverlaysFile.java
deleted file mode 100644
index 2909ea9..0000000
--- a/app/src/main/java/masquerade/substratum/util/ReadOverlaysFile.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package masquerade.substratum.util;
-
-import android.os.Environment;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-public class ReadOverlaysFile {
-
-    public static List<String> main(String argv[]) {
-
-        File current_overlays = new File(Environment
-                .getExternalStorageDirectory().getAbsolutePath() +
-                "/.substratum/current_overlays.xml");
-        if (current_overlays.exists()) {
-            Root.runCommand("rm " + Environment
-                    .getExternalStorageDirectory().getAbsolutePath() +
-                    "/.substratum/current_overlays.xml");
-        }
-        Root.runCommand("cp /data/system/overlays.xml " +
-                Environment
-                        .getExternalStorageDirectory().getAbsolutePath() +
-                "/.substratum/current_overlays.xml");
-
-        File file = new File(argv[0]);
-        int state_count = Integer.parseInt(argv[1]);
-
-        List<String> list = new ArrayList<>();
-
-        try (BufferedReader br = new BufferedReader(new FileReader(file))) {
-            for (String line; (line = br.readLine()) != null; ) {
-                if (line.contains("state=\"" + state_count + "\"")) {
-                    String[] split = line.substring(21).split("\\s+");
-                    list.add(split[0].substring(1, split[0].length() - 1));
-                }
-            }
-        } catch (IOException ioe) {
-            // Exception
-        }
-        return list;
-    }
-}
\ No newline at end of file
diff --git a/app/src/main/java/masquerade/substratum/util/Root.java b/app/src/main/java/masquerade/substratum/util/Root.java
deleted file mode 100644
index 7c80720..0000000
--- a/app/src/main/java/masquerade/substratum/util/Root.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package masquerade.substratum.util;
-
-import java.io.BufferedReader;
-import java.io.BufferedWriter;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
-
-public class Root {
-
-    private static SU su;
-
-    public static boolean requestRootAccess() {
-        SU su = getSU();
-        su.runCommand("echo /testRoot/");
-        return !su.denied;
-    }
-
-    public static String runCommand(String command) {
-        return getSU().runCommand(command);
-    }
-
-    private static SU getSU() {
-        if (su == null) su = new SU();
-        else if (su.closed || su.denied) su = new SU();
-        return su;
-    }
-
-    private static class SU {
-
-        private Process process;
-        private BufferedWriter bufferedWriter;
-        private BufferedReader bufferedReader;
-        private boolean closed;
-        private boolean denied;
-        private boolean firstTry;
-
-        SU() {
-            try {
-                firstTry = true;
-                process = Runtime.getRuntime().exec("su");
-                bufferedWriter = new BufferedWriter(new OutputStreamWriter(process
-                        .getOutputStream()));
-                bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream
-                        ()));
-            } catch (IOException e) {
-                denied = true;
-                closed = true;
-            }
-        }
-
-        synchronized String runCommand(final String command) {
-            try {
-                StringBuilder sb = new StringBuilder();
-                String callback = "/shellCallback/";
-                bufferedWriter.write(command + "\necho " + callback + "\n");
-                bufferedWriter.flush();
-
-                int i;
-                char[] buffer = new char[256];
-                while (true) {
-                    sb.append(buffer, 0, bufferedReader.read(buffer));
-                    if ((i = sb.indexOf(callback)) > -1) {
-                        sb.delete(i, i + callback.length());
-                        break;
-                    }
-                }
-                firstTry = false;
-                return sb.toString().trim();
-            } catch (IOException e) {
-                closed = true;
-                e.printStackTrace();
-                if (firstTry) denied = true;
-            } catch (ArrayIndexOutOfBoundsException e) {
-                denied = true;
-            } catch (Exception e) {
-                e.printStackTrace();
-                denied = true;
-            }
-            return null;
-        }
-    }
-}
\ No newline at end of file
diff --git a/app/src/main/java/masquerade/substratum/util/Uninstaller.java b/app/src/main/java/masquerade/substratum/util/Uninstaller.java
deleted file mode 100644
index 4b1b056..0000000
--- a/app/src/main/java/masquerade/substratum/util/Uninstaller.java
+++ /dev/null
@@ -1,107 +0,0 @@
-package masquerade.substratum.util;
-
-import android.content.Intent;
-import android.os.AsyncTask;
-import android.os.Environment;
-import android.util.Log;
-
-import java.util.ArrayList;
-import java.util.List;
-
-class Uninstaller {
-
-    private Intent mIntent;
-    private String uninstallString;
-    private boolean specific;
-    private boolean restartSystemUI;
-
-    void uninstall(Intent mIntent, String uninstallString,
-                   boolean specific, boolean restartSystemUI) {
-        this.mIntent = mIntent;
-        this.uninstallString = uninstallString;
-        this.specific = specific;
-        this.restartSystemUI = restartSystemUI;
-        new UninstallAsync().execute("");
-    }
-
-    private class UninstallAsync extends AsyncTask<String, Integer, String> {
-
-        @Override
-        protected String doInBackground(String... sUrl) {
-            uninstall_handler(mIntent, uninstallString, specific, restartSystemUI);
-            return null;
-        }
-
-        private void uninstall_handler(Intent intent, String inheritor,
-                                       boolean specific, boolean restartSystemUI) {
-            try {
-                String final_commands_disable = "";
-                String final_commands_uninstall = "";
-
-                Root.runCommand(
-                        "pm grant masquerade.substratum android.permission.READ_EXTERNAL_STORAGE");
-                Root.runCommand(
-                        "pm grant masquerade.substratum android.permission.WRITE_EXTERNAL_STORAGE");
-
-                ArrayList<String> packages_to_uninstall =
-                        new ArrayList<>(intent.getStringArrayListExtra(inheritor));
-                String[] state5initial = {Environment.getExternalStorageDirectory()
-                        .getAbsolutePath() +
-                        "/.substratum/current_overlays.xml", "5"};
-                List<String> state5overlays = ReadOverlaysFile.main(state5initial);
-
-                for (int i = 0; i < packages_to_uninstall.size(); i++) {
-                    String current = packages_to_uninstall.get(i);
-
-                    Log.d("Masquerade", "Intent received to purge referendum package file \"" +
-                            current + "\"");
-                    if (state5overlays.contains(packages_to_uninstall.get(i))) {
-                        Log.d("Masquerade", "Package file \"" + current +
-                                "\" requires an overlay disable prior to uninstall...");
-                        if (final_commands_disable.length() == 0) {
-                            final_commands_disable = "om disable " + current;
-                        } else {
-                            final_commands_disable = final_commands_disable + " " + current;
-                        }
-
-                        if (final_commands_uninstall.length() == 0) {
-                            final_commands_uninstall = "pm uninstall " + current;
-                        } else {
-                            final_commands_uninstall = final_commands_uninstall +
-                                    " && pm uninstall " + current;
-                        }
-                    } else {
-                        Log.d("Masquerade", "\"" + current +
-                                "\" has been redirected to the package manager in " +
-                                "preparations of removal...");
-                        Root.runCommand("pm uninstall " + current);
-                    }
-                }
-
-                if (final_commands_disable.length() > 0) {
-                    Log.d("Masquerade", "Disable commands: " + final_commands_disable);
-                    Root.runCommand(final_commands_disable);
-                }
-                if (final_commands_uninstall.length() > 0) {
-                    Log.d("Masquerade", "Uninstall commands: " + final_commands_uninstall);
-                    Root.runCommand(final_commands_uninstall);
-                }
-
-                if (restartSystemUI) {
-                    Root.runCommand("pkill com.android.systemui");
-                }
-
-                if (!specific) {
-                    // Clear the resource idmapping files generated by OMS
-                    Log.d("Masquerade", "Cleaning up resource-cache directory...");
-                    Root.runCommand("rm /data/resource-cache/*");
-                    // Now clear the persistent overlays database
-                    Log.d("Masquerade", "Finalizing clean up of persistent overlays database...");
-                    Root.runCommand("rm -rf /data/system/overlays.xml");
-                }
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/app/src/main/java/masquerade/substratum/utils/IOUtils.java b/app/src/main/java/masquerade/substratum/utils/IOUtils.java
new file mode 100644
index 0000000..092c58c
--- /dev/null
+++ b/app/src/main/java/masquerade/substratum/utils/IOUtils.java
@@ -0,0 +1,170 @@
+
+package masquerade.substratum.utils;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+
+import android.os.FileUtils;
+
+public class IOUtils {
+    public static final String SYSTEM_THEME_PATH = "/data/system/theme";
+    public static final String SYSTEM_THEME_FONT_PATH = SYSTEM_THEME_PATH + File.separator
+            + "fonts";
+    public static final String SYSTEM_THEME_AUDIO_PATH = SYSTEM_THEME_PATH + File.separator
+            + "audio";
+    public static final String SYSTEM_THEME_RINGTONE_PATH = SYSTEM_THEME_AUDIO_PATH
+            + File.separator + "ringtones";
+    public static final String SYSTEM_THEME_NOTIFICATION_PATH = SYSTEM_THEME_AUDIO_PATH
+            + File.separator + "notifications";
+    public static final String SYSTEM_THEME_ALARM_PATH = SYSTEM_THEME_AUDIO_PATH
+            + File.separator + "alarms";
+    public static final String SYSTEM_THEME_UI_SOUNDS_PATH = SYSTEM_THEME_AUDIO_PATH
+            + File.separator + "ui";
+    public static final String SYSTEM_THEME_BOOTANIMATION_PATH = SYSTEM_THEME_PATH + File.separator
+            + "bootanimation.zip";
+
+    public static boolean dirExists(String dirPath) {
+        final File dir = new File(dirPath);
+        return dir.exists() && dir.isDirectory();
+    }
+
+    public static void createDirIfNotExists(String dirPath) {
+        if (!dirExists(dirPath)) {
+            File dir = new File(dirPath);
+            if (dir.mkdir()) {
+                FileUtils.setPermissions(dir, FileUtils.S_IRWXU |
+                        FileUtils.S_IRWXG | FileUtils.S_IROTH | FileUtils.S_IXOTH, -1, -1);
+            }
+        }
+    }
+
+    public static void createFontDirIfNotExists() {
+        createDirIfNotExists(SYSTEM_THEME_FONT_PATH);
+    }
+
+    public static void createAudioDirIfNotExists() {
+        createDirIfNotExists(SYSTEM_THEME_AUDIO_PATH);
+    }
+
+    public static void createRingtoneDirIfNotExists() {
+        createDirIfNotExists(SYSTEM_THEME_RINGTONE_PATH);
+    }
+
+    public static void createNotificationDirIfNotExists() {
+        createDirIfNotExists(SYSTEM_THEME_NOTIFICATION_PATH);
+    }
+
+    public static void createAlarmDirIfNotExists() {
+        createDirIfNotExists(SYSTEM_THEME_ALARM_PATH);
+    }
+
+    public static void createUiSoundsDirIfNotExists() {
+        createDirIfNotExists(SYSTEM_THEME_UI_SOUNDS_PATH);
+    }
+
+    public static void deleteThemedFonts() {
+        try {
+            deleteRecursive(new File(SYSTEM_THEME_FONT_PATH));
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+    
+    public static void deleteThemedAudio() {
+        try {
+            deleteRecursive(new File(SYSTEM_THEME_UI_SOUNDS_PATH));
+            deleteRecursive(new File(SYSTEM_THEME_RINGTONE_PATH));
+            deleteRecursive(new File(SYSTEM_THEME_NOTIFICATION_PATH));
+            deleteRecursive(new File(SYSTEM_THEME_ALARM_PATH));
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void copyFolder(String source, String dest) {
+        File dir = new File(source);
+        File[] files = dir.listFiles();
+        for (File file : files) {
+            try {
+                String sourceFile = dir + File.separator + file.getName();
+                String destinationFile = dest + File.separator + file.getName();
+                bufferedCopy(new File(sourceFile), new File(destinationFile));
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public static void unzip(String source, String destination) {
+        try (ZipInputStream inputStream = new ZipInputStream(
+                new BufferedInputStream(new FileInputStream(source)))) {
+            ZipEntry zipEntry;
+            int count;
+            byte[] buffer = new byte[8192];
+            while ((zipEntry = inputStream.getNextEntry()) != null) {
+                File file = new File(destination, zipEntry.getName());
+                File dir = zipEntry.isDirectory() ? file : file.getParentFile();
+                if (!dir.isDirectory() && !dir.mkdirs())
+                    throw new FileNotFoundException("Failed to ensure directory: " +
+                            dir.getAbsolutePath());
+                if (zipEntry.isDirectory())
+                    continue;
+                try (FileOutputStream outputStream = new FileOutputStream(file)) {
+                    while ((count = inputStream.read(buffer)) != -1)
+                        outputStream.write(buffer, 0, count);
+                }
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void bufferedCopy(String source, String dest) {
+        try {
+            bufferedCopy(new FileInputStream(source), new FileOutputStream(dest));
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void bufferedCopy(File source, File dest) {
+        try {
+            bufferedCopy(new FileInputStream(source), new FileOutputStream(dest));
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void bufferedCopy(InputStream source, OutputStream dest) {
+        try {
+            BufferedInputStream in = new BufferedInputStream(source);
+            BufferedOutputStream out = new BufferedOutputStream(dest);
+            byte[] buff = new byte[32 * 1024];
+            int len;
+            while ((len = in.read(buff)) > 0) {
+                out.write(buff, 0, len);
+            }
+            in.close();
+            out.close();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void deleteRecursive(File fileOrDirectory) {
+        if (fileOrDirectory.isDirectory())
+            for (File child : fileOrDirectory.listFiles())
+                deleteRecursive(child);
+
+        fileOrDirectory.delete();
+    }
+
+}
diff --git a/app/src/main/java/masquerade/substratum/utils/SoundUtils.java b/app/src/main/java/masquerade/substratum/utils/SoundUtils.java
new file mode 100644
index 0000000..72c6052
--- /dev/null
+++ b/app/src/main/java/masquerade/substratum/utils/SoundUtils.java
@@ -0,0 +1,210 @@
+
+package masquerade.substratum.utils;
+
+import java.io.File;
+import java.util.Arrays;
+
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.media.RingtoneManager;
+import android.net.Uri;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.provider.MediaStore;
+import android.util.Log;
+import android.provider.Settings;
+
+public class SoundUtils {
+    private static final String SYSTEM_MEDIA_PATH = "/system/media/audio";
+    private static final String SYSTEM_ALARMS_PATH =
+            SYSTEM_MEDIA_PATH + File.separator + "alarms";
+    private static final String SYSTEM_RINGTONES_PATH =
+            SYSTEM_MEDIA_PATH + File.separator + "ringtones";
+    private static final String SYSTEM_NOTIFICATIONS_PATH =
+            SYSTEM_MEDIA_PATH + File.separator + "notifications";
+    private static final String MEDIA_CONTENT_URI = "content://media/internal/audio/media";
+
+    public static void updateGlobalSettings(ContentResolver resolver, String uri, String val) {
+        Settings.Global.putStringForUser(resolver, uri, val, UserHandle.USER_ALL);
+    }
+
+    public static boolean setUISounds(ContentResolver resolver, String sound_name, String location) {
+        if (allowedUISound(sound_name)) {
+            updateGlobalSettings(resolver, sound_name, location);
+            return true;
+        }
+        return false;
+    }
+
+    public static void setDefaultUISounds(ContentResolver resolver, String sound_name,
+            String sound_file) {
+        updateGlobalSettings(resolver, sound_name, "/system/media/audio/ui/" + sound_file);
+    }
+
+    // This string array contains all the SystemUI acceptable sound files
+    public static Boolean allowedUISound(String targetValue) {
+        String[] allowed_themable = {
+                "lock_sound",
+                "unlock_sound",
+                "low_battery_sound"
+        };
+        return Arrays.asList(allowed_themable).contains(targetValue);
+    }
+
+    public static String getDefaultAudiblePath(int type) {
+        final String name;
+        final String path;
+        switch (type) {
+            case RingtoneManager.TYPE_ALARM:
+                name = SystemProperties.get("ro.config.alarm_alert");
+                path = name != null ? SYSTEM_ALARMS_PATH + File.separator + name : null;
+                break;
+            case RingtoneManager.TYPE_NOTIFICATION:
+                name = SystemProperties.get("ro.config.notification_sound");
+                path = name != null ? SYSTEM_NOTIFICATIONS_PATH + File.separator + name : null;
+                break;
+            case RingtoneManager.TYPE_RINGTONE:
+                name = SystemProperties.get("ro.config.ringtone");
+                path = name != null ? SYSTEM_RINGTONES_PATH + File.separator + name : null;
+                break;
+            default:
+                path = null;
+                break;
+        }
+        return path;
+    }
+
+    public static void clearAudibles(Context context, String audiblePath) {
+        final File audibleDir = new File(audiblePath);
+        if (audibleDir.exists() && audibleDir.isDirectory()) {
+            String[] files = audibleDir.list();
+            final ContentResolver resolver = context.getContentResolver();
+            for (String s : files) {
+                final String filePath = audiblePath + File.separator + s;
+                Uri uri = MediaStore.Audio.Media.getContentUriForPath(filePath);
+                resolver.delete(uri, MediaStore.MediaColumns.DATA + "=\""
+                        + filePath + "\"", null);
+                boolean deleted = (new File(filePath)).delete();
+                if (deleted)
+                    Log.e("SoundsHandler", "Database cleared");
+            }
+        }
+    }
+
+    public static boolean setAudible(Context context, File ringtone, File ringtoneCache, int type,
+            String name) {
+        final String path = ringtone.getAbsolutePath();
+        final String mimeType = name.endsWith(".ogg") ? "application/ogg" : "application/mp3";
+        ContentValues values = new ContentValues();
+        values.put(MediaStore.MediaColumns.DATA, path);
+        values.put(MediaStore.MediaColumns.TITLE, name);
+        values.put(MediaStore.MediaColumns.MIME_TYPE, mimeType);
+        values.put(MediaStore.MediaColumns.SIZE, ringtoneCache.length());
+        values.put(MediaStore.Audio.Media.IS_RINGTONE, type == RingtoneManager.TYPE_RINGTONE);
+        values.put(MediaStore.Audio.Media.IS_NOTIFICATION,
+                type == RingtoneManager.TYPE_NOTIFICATION);
+        values.put(MediaStore.Audio.Media.IS_ALARM, type == RingtoneManager.TYPE_ALARM);
+        values.put(MediaStore.Audio.Media.IS_MUSIC, false);
+
+        Uri uri = MediaStore.Audio.Media.getContentUriForPath(path);
+        Uri newUri = null;
+        Cursor c = context.getContentResolver().query(uri,
+                new String[] {
+                    MediaStore.MediaColumns._ID
+                },
+                MediaStore.MediaColumns.DATA + "='" + path + "'",
+                null, null);
+        if (c != null && c.getCount() > 0) {
+            c.moveToFirst();
+            long id = c.getLong(0);
+            c.close();
+            newUri = Uri.withAppendedPath(Uri.parse(MEDIA_CONTENT_URI), "" + id);
+            context.getContentResolver().update(uri, values,
+                    MediaStore.MediaColumns._ID + "=" + id, null);
+        }
+        if (newUri == null)
+            newUri = context.getContentResolver().insert(uri, values);
+        try {
+            RingtoneManager.setActualDefaultRingtoneUri(context, type, newUri);
+        } catch (Exception e) {
+            return false;
+        }
+        return true;
+    }
+
+    public static boolean setUIAudible(Context context, File localized_ringtone,
+            File ringtone_file, int type, String name) {
+        final String path = ringtone_file.getAbsolutePath();
+
+        final String path_clone = "/system/media/audio/ui/" + name + ".ogg";
+
+        ContentValues values = new ContentValues();
+        values.put(MediaStore.MediaColumns.DATA, path);
+        values.put(MediaStore.MediaColumns.TITLE, name);
+        values.put(MediaStore.MediaColumns.MIME_TYPE, "application/ogg");
+        values.put(MediaStore.MediaColumns.SIZE, localized_ringtone.length());
+        values.put(MediaStore.Audio.Media.IS_RINGTONE, false);
+        values.put(MediaStore.Audio.Media.IS_NOTIFICATION, false);
+        values.put(MediaStore.Audio.Media.IS_ALARM, false);
+        values.put(MediaStore.Audio.Media.IS_MUSIC, true);
+
+        Uri uri = MediaStore.Audio.Media.getContentUriForPath(path);
+        Uri newUri = null;
+        Cursor c = context.getContentResolver().query(uri,
+                new String[] {
+                    MediaStore.MediaColumns._ID
+                },
+                MediaStore.MediaColumns.DATA + "='" + path_clone + "'",
+                null, null);
+        if (c != null && c.getCount() > 0) {
+            c.moveToFirst();
+            long id = c.getLong(0);
+            Log.e("ContentResolver", id + "");
+            c.close();
+            newUri = Uri.withAppendedPath(Uri.parse(MEDIA_CONTENT_URI), "" + id);
+            try {
+                context.getContentResolver().update(uri, values,
+                        MediaStore.MediaColumns._ID + "=" + id, null);
+            } catch (Exception e) {
+                Log.d("SoundsHandler", "The content provider does not need to be updated.");
+            }
+        }
+        if (newUri == null)
+            newUri = context.getContentResolver().insert(uri, values);
+        try {
+            RingtoneManager.setActualDefaultRingtoneUri(context, type, newUri);
+        } catch (Exception e) {
+            e.printStackTrace();
+            return false;
+        }
+        return true;
+    }
+
+    public static boolean setDefaultAudible(Context context, int type) {
+        final String audiblePath = getDefaultAudiblePath(type);
+        if (audiblePath != null) {
+            Uri uri = MediaStore.Audio.Media.getContentUriForPath(audiblePath);
+            Cursor c = context.getContentResolver().query(uri,
+                    new String[] {
+                        MediaStore.MediaColumns._ID
+                    },
+                    MediaStore.MediaColumns.DATA + "='" + audiblePath + "'",
+                    null, null);
+            if (c != null && c.getCount() > 0) {
+                c.moveToFirst();
+                long id = c.getLong(0);
+                c.close();
+                uri = Uri.withAppendedPath(
+                        Uri.parse(MEDIA_CONTENT_URI), "" + id);
+            }
+            if (uri != null)
+                RingtoneManager.setActualDefaultRingtoneUri(context, type, uri);
+        } else {
+            return false;
+        }
+        return true;
+    }
+
+}
-- 
2.11.1

